#!/usr/bin/env python
# -*- encoding: utf-8 -*-
"""
This modules defines sensor models of different tactile sensors.

"""

import os
import collections

import numpy as np
import tflearn

import geometry_msgs.msg
import udom_common_msgs.msg
import udom_perception_msgs.msg


def format_electrodes(electrodes):
    """
    Convert the electrodes, as returned by the numpy.loadtxt function, to a dictionary
    in order to avoid using pandas package. The keys are the names of the electrodes
    and the values are an array representing the positions along the three dimensions
    followed by the normal vector, see the example.

    :param electrodes: The electrodes configuration.
    :type electrodes: numpy.ndarray

    :return: Ordered dictionary representing the electrodes configuration.
    :rtype: collections.OrderedDict

    Examples
    --------
    >>> dd = format_electrodes(electrodes)
    >>> dd['E1']
    [0.99299997, -4.855, -1.1160001, 0.19599999, -0.95599997, -0.22]

    """
    dd = collections.OrderedDict()
    for ee in electrodes:
        dd[ee[0]] = list(ee)[1:]

    return dd


class TactileSensor(object):
    """
    Basic class for a tactile sensor. An object of a derived class should be able
    to compute at least the following:

    * contact points: points of contact where an external wrench(es) is applied.
    * contact wrenches: forces generated by the contacts, separated into their linear
        and angular parts.
    * contact areas: describes as intervals (minimum and maximum values) of the
        parameters for the parametric equation of sensor_surface that represent
        the contact areas.

    """
    def __init__(self, surface):
        """
        Returns a tactile sensor model object that is represented by a parametric
        surface.

        :param surface: Name of the parametric equation that describes the surface
            of the sensor.
        :type surface: str

        :return: Tactile sensor model.
        :rtype: sensor_model.tactile_sensor.TactileSensor

        """
        self.sensor_surface = surface

    def contact_points(self, tactile_data):
        """
        Returns a list of points representing the location of
        every contact measured by the sensor (tactile_data).

        :param tactile_data: The tactile data.
        :type tactile_data: depends on the specific tactile sensor.

        :return: Points representing the location of each contact.
        :rtype: geometry_msgs/Point[]

        """
        raise NotImplementedError

    def contact_wrenches(self, tactile_data):
        """
        Returns the linear (force) and angular (torque) components that each contact
        generates.

        :param tactile_data: The tactile data.
        :type tactile_data: depends on the specific tactile sensor.

        :return: Wrenches generated by each contact.
        :rtype: geometry_msgs/Wrench[]

        """
        raise NotImplementedError

    def contact_areas(self, tactile_data):
        """
        Returns a list of closed intervals representing the contacts areas as sections
        of the parametric surface that describes the sensor's surface.

        :param tactile_data: The tactile data.
        :type tactile_data: depends on the specific tactile sensor.

        :return: Intervals for the parameters that represent the contact areas.
        :rtype: udom_common_msgs/ClosedInterval[], udom_common_msgs/ClosedInterval[]

        """
        raise NotImplementedError

    def contact_info(self, tactile_data):
        """
        Returns the contact information based on the tactile data.

        :param tactile_data: The tactile data.
        :type tactile_data: depends on the specific tactile sensor.

        :return: Points representing the location of each contact.
        :rtype:  udom_perception_msgs.msg.ContactInfo

        """
        contact_info = udom_perception_msgs.msg.ContactInfo()
        contact_info.sensor_surface = self.sensor_surface
        contact_info.contact_points = self.contact_points(tactile_data)
        contact_info.wrenches = self.contact_wrenches(tactile_data)
        contact_info.u, contact_info.v = self.contact_areas(tactile_data)

        return contact_info


class BioTacSensor(TactileSensor):
    """
    Basic class for a BioTac sensor. An object of a derived class should be able
    to compute at least the following:

    * contact points: points of contact where an external wrench(es) is applied.
    * contact wrenches: forces generated by the contacts, separated into their linear
        and angular parts.
    * contact areas: describes as intervals (minimum and maximum values) of the
        parameters for the parametric equation of sensor_surface that represent
        the contact areas.

    """
    def __init__(self, surface, electrodes_config_file='config/biotac_electrodes_pose.csv'):
        """
        Returns a BioTac sensor model object that is represented by a parametric
        surface.

        :param surface: Name of the parametric equation that describes the surface
            of the sensor.
        :type surface: str

        :param electrodes_config_file: File describing the configuration of the electrodes.
        :type electrodes_config_file: str

        :return: BioTac sensor model.
        :rtype: sensor_model.tactile_sensor.BioTacSensor

        """
        super(BioTacSensor, self).__init__(surface)
        config_file = os.path.join(os.path.dirname(__file__), electrodes_config_file)

        electrodes = np.loadtxt(
            config_file, delimiter=',',
            dtype={
                'names': ('electrode', 'pos_x', 'pos_y', 'pos_z', 'normal_x', 'normal_y', 'normal_z'),
                'formats': ('S3', 'f', 'f', 'f', 'f', 'f', 'f')
            }
        )

        self.electrodes = format_electrodes(electrodes)

        # Extract the location (positions) and orientation (normals) the electrodes
        pos_x = np.array([vv[0] for key, vv in self.electrodes.iteritems() if 'E' in key])
        pos_y = np.array([vv[1] for key, vv in self.electrodes.iteritems() if 'E' in key])
        pos_z = np.array([vv[2] for key, vv in self.electrodes.iteritems() if 'E' in key])
        normal_x = np.array([vv[3] for key, vv in self.electrodes.iteritems() if 'E' in key])
        normal_y = np.array([vv[4] for key, vv in self.electrodes.iteritems() if 'E' in key])
        normal_z = np.array([vv[5] for key, vv in self.electrodes.iteritems() if 'E' in key])

        positions = np.hstack((pos_x, pos_y, pos_z))
        self.positions = positions.reshape((3, 19))

        normals = np.hstack((normal_x, normal_y, normal_z))
        self.normals = normals.reshape((3, 19))

    def contact_points(self, tactile_data):
        """
        Returns a list of points representing the location of
        every contact measured by the sensor (tactile_data).

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Points representing the location of each contact.
        :rtype: geometry_msgs/Point[]

        """
        raise NotImplementedError

    def contact_wrenches(self, tactile_data):
        """
        Returns the linear (force) and angular (torque) components that each contact
        generates.

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Wrenches generated by each contact.
        :rtype: geometry_msgs/Wrench[]

        """
        raise NotImplementedError

    def contact_areas(self, tactile_data):
        """
        Returns a list of closed intervals representing the contacts areas as sections
        of the parametric surface that describes the sensor's surface.

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Intervals for the parameters that represent the contact areas.
        :rtype: udom_common_msgs/ClosedInterval[], udom_common_msgs/ClosedInterval[]

        """
        raise NotImplementedError

    def contact_info(self, tactile_data):
        """
        Returns the contact information based on the tactile data.

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Points representing the location of each contact.
        :rtype:  udom_perception_msgs.msg.ContactInfo

        """
        return super(BioTacSensor, self).contact_info(tactile_data)


class BioTacSimple(BioTacSensor):
    """
    Class representing a simple model of the BioTac sensor.
    Based on the model described in [1].

    [1] Lin, C.H., Fishel, J.A., Loeb, G.E., "Estimating point of contact, force and
    torque in a biomimetic tactile sensor with deformable skin", SynTouch LLC, 2013.

    """
    def __init__(
            self, surface="geometric_simple", scale_factor=(1.0, 1.0, 1.0),
            electrodes_config_file=None
    ):
        """
        Returns a simple version of the BioTac sensor model object that is represented
        by a parametric surface.

        :param surface: Name of the parametric equation that describes the surface
            of the sensor.
        :type surface: str

        :param scale_factor: A scaling value, for each dimension, to convert the
            electrodes' values to Newtons.
        :type scale_factor: tuple

        :return: BioTac sensor model.
        :rtype: sensor_model.tactile_sensor.BioTacSimple

        """
        if electrodes_config_file is not None:
            super(BioTacSimple, self).__init__(surface, electrodes_config_file)
        else:
            super(BioTacSimple, self).__init__(surface)

        assert isinstance(scale_factor, tuple) and len(scale_factor) == 3, \
            "'scale_factor' must be a 3-element tuple, not *{}*.".format(scale_factor)
        self.scale_factor = scale_factor

    def contact_points(self, tactile_data):
        """
        Returns a list of points representing the location of
        every contact measured by the sensor (tactile_data).

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Points representing the location of each contact.
        :rtype: geometry_msgs/Point[]

        """
        points = [geometry_msgs.msg.Point()]

        return points

    def contact_wrenches(self, tactile_data):
        """
        Returns the linear (force) and angular (torque) components that each contact
        generates.

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Wrenches generated by each contact.
        :rtype: geometry_msgs/Wrench[]

        """
        wrench = geometry_msgs.msg.Wrench()
        scaling = np.array(self.scale_factor)
        impedance_values = np.array(tactile_data.electrodes)

        # Compute the force as in Eq. 3, from [1].
        force = np.multiply(scaling, np.dot(impedance_values, self.normals.T))
        wrench.force.x = force[0]
        wrench.force.y = force[1]
        wrench.force.z = force[2]

        # Compute the torque as in Eq. 4, from [1].
        torque = [
            np.cross(np.array(pos), ee * np.array(nn)) for pos, nn, ee
            in zip(self.positions.T, self.normals.T, tactile_data.electrodes)
        ]
        # Convert to meters since the positions are specified in mm.
        torque = np.sum(torque, axis=0) / 1000.0
        wrench.torque.x = torque[0]
        wrench.torque.y = torque[1]
        wrench.torque.z = torque[2]

        return [wrench]

    def contact_areas(self, tactile_data):
        """
        Returns a list of closed intervals representing the contacts areas as sections
        of the parametric surface that describes the sensor's surface.

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Intervals for the parameters that represent the contact areas.
        :rtype: udom_common_msgs/ClosedInterval[], udom_common_msgs/ClosedInterval[]

        """
        u = [udom_common_msgs.msg.ClosedInterval()]
        v = [udom_common_msgs.msg.ClosedInterval()]

        return u, v

    def contact_info(self, tactile_data):
        """
        Returns the contact information based on the tactile data.

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Points representing the location of each contact.
        :rtype:  udom_perception_msgs.msg.ContactInfo

        """
        return super(BioTacSimple, self).contact_info(tactile_data)


class BioTacRNN(BioTacSensor):
    """
    Class representing a model of the BioTac sensor learned with Recurrent Neural Networks.

    """
    def __init__(
            self, surface="geometric_simple", electrodes_config_file=None,
            input_features=19, output_features=3, time_steps=50, hidden_units=20,
            model_path="config/learned_rnn_model"):
        """
        Returns a simple version of the BioTac sensor model object that is represented
        by a parametric surface.

        :param surface: Name of the parametric equation that describes the surface
            of the sensor.
        :type surface: str

        :param input_features: Number of input features for the model.
        :type input_features: int

        :param output_features: Number of output features the model must learn.
        :type output_features: int

        :param time_steps: Length of the input sequence.
        :type time_steps: int

        :param hidden_units: Number of hidden units for the hidden layers.
        :type hidden_units: int

        :param model_path: Path where the model for the RNN has been saved.
        :type model_path: str

        :return: BioTac sensor model.
        :rtype: sensor_model.tactile_sensor.BioTacRNN

        """
        if electrodes_config_file is not None:
            super(BioTacRNN, self).__init__(surface, electrodes_config_file)
        else:
            super(BioTacRNN, self).__init__(surface)

        self.input_features = input_features
        self.output_features = output_features
        self.time_steps = time_steps
        self.hidden_units = hidden_units
        self.model_path = model_path

        self.model = self.build_network()

    def build_network(self):
        """Builds a recurrent neural network model.

        :return: Neural network model.
        :rtype: tflearn.DNN

        """
        input_layer = tflearn.input_data(
            shape=[None, self.time_steps, self.input_features], name='input_layer')
        layer_1 = tflearn.lstm(
            input_layer, self.hidden_units, return_seq=True, name='layer1')
        layer_2 = tflearn.lstm(layer_1, self.hidden_units, name='layer2')
        output_layer = tflearn.fully_connected(
            layer_2, self.output_features, name='output_layer')

        regression_layer = tflearn.regression(
            output_layer, optimizer='sgd', loss='mean_square',
            metric='R2', learning_rate=0.01)

        return tflearn.DNN(
            regression_layer, tensorboard_verbose=2,
            checkpoint_path='{}/biotac.tfl.ckpt'.format(
                os.path.join(os.path.dirname(__file__), self.model_path)))

    def contact_points(self, tactile_data):
        """
        Returns a list of points representing the location of
        every contact measured by the sensor (tactile_data).

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Points representing the location of each contact.
        :rtype: geometry_msgs/Point[]

        """
        points = [geometry_msgs.msg.Point()]

        return points

    def contact_wrenches(self, tactile_data):
        """
        Returns the linear (force) and angular (torque) components that each contact
        generates.

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Wrenches generated by each contact.
        :rtype: geometry_msgs/Wrench[]

        """
        wrench = geometry_msgs.msg.Wrench()
        impedance_values = np.array(tactile_data.electrodes)

        self.model.load(
            os.path.join(os.path.dirname(__file__), self.model_path + "/biotac.tfl"))

        force = self.model.predict(impedance_values)
        wrench.force.x = force[0][0]
        wrench.force.y = force[0][1]
        wrench.force.z = force[0][2]

        # TODO: add torque

        return [wrench]

    def contact_areas(self, tactile_data):
        """
        Returns a list of closed intervals representing the contacts areas as sections
        of the parametric surface that describes the sensor's surface.

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Intervals for the parameters that represent the contact areas.
        :rtype: udom_common_msgs/ClosedInterval[], udom_common_msgs/ClosedInterval[]

        """
        u = [udom_common_msgs.msg.ClosedInterval()]
        v = [udom_common_msgs.msg.ClosedInterval()]

        return u, v

    def contact_info(self, tactile_data):
        """
        Returns the contact information based on the tactile data.

        :param tactile_data: The tactile data.
        :type tactile_data: udom_perception_msgs.msg.BiotacStamped

        :return: Points representing the location of each contact.
        :rtype:  udom_perception_msgs.msg.ContactInfo

        """
        return super(BioTacRNN, self).contact_info(tactile_data)
